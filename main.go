package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
)

/* Full mail struct for posterity; generated from https://mholt.github.io/json-to-go/
type AutoGenerated struct {
	Data struct {
		Fromfull string `json:"fromfull"`
		Headers struct {
			MimeVersion string `json:"mime-version"`
			Date string `json:"date"`
			Subject string `json:"subject"`
			XSgEid string `json:"x-sg-eid"`
			MessageID string `json:"message-id"`
			Received string `json:"received"`
			From string `json:"from"`
			ContentType string `json:"content-type"`
			To string `json:"to"`
			DkimSignature string `json:"dkim-signature"`
		} `json:"headers"`
		Subject string `json:"subject"`
		RequestID string `json:"requestId"`
		Parts []struct {
			Headers struct {
				ContentTransferEncoding string `json:"content-transfer-encoding"`
				ContentType string `json:"content-type"`
			} `json:"headers"`
			Body string `json:"body"`
		} `json:"parts"`
		From string `json:"from"`
		Origfrom string `json:"origfrom"`
		To string `json:"to"`
		ID string `json:"id"`
		Time int64 `json:"time"`
		SecondsAgo int `json:"seconds_ago"`
	} `json:"data"`
} */

type mail struct {
	Data struct {
		Subject string `json:"subject"`
		Parts   []struct {
			Body string `json:"body"`
		} `json:"parts"`
		From string `json:"from"`
	} `json:"data"`
}

type publicMsg struct {
	ID string `json:"id"`
	To string `json:"to"`
}

type mailboxDetails struct {
	PublicMsgs []publicMsg `json:"public_msgs"`
}

func getMailboxDetails(localPart string) (mailboxDetails, error) {
	webInboxURL := "https://www.mailinator.com/api/webinbox2?x=0&public_to=" + localPart
	fmt.Println("Retrieving URL:", webInboxURL)

	mbxDetails := mailboxDetails{}
	resp, err := http.Get(webInboxURL)
	if err != nil {
		return mbxDetails, err
	}

	defer resp.Body.Close()
	err = json.NewDecoder(resp.Body).Decode(&mbxDetails)
	// No need for error check here as we return mbxDetails and err whether
	// we have an error or not.
	return mbxDetails, err
}

func getCookies(latestMsg publicMsg) ([]*http.Cookie, error) {
	// This request is for nothing but getting required cookies.
	// Otherwise, the subsequent request fails.
	inboxURL := "https://www.mailinator.com/inbox2.jsp?public_to=" + latestMsg.To
	fmt.Println("Retrieving URL:", inboxURL)

	inboxResp, err := http.Get(inboxURL)
	defer inboxResp.Body.Close()
	if err != nil {
		return nil, err
	}

	cookies := inboxResp.Cookies()
	return cookies, err
}

func getMail(latestMsg publicMsg, cookies []*http.Cookie) error {
	msgURL := "https://www.mailinator.com/fetchmail?msgid=" + latestMsg.ID + "&zone=public"
	fmt.Println("Retrieving URL:", msgURL)
	req, err := http.NewRequest("GET", msgURL, nil)
	if err != nil {
		return err
	}

	for _, c := range cookies {
		req.AddCookie(c)
	}

	client := &http.Client{}

	mailResp, err := client.Do(req)
	defer mailResp.Body.Close()
	if err != nil {
		return err
	}

	mailMessage := mail{}
	err = json.NewDecoder(mailResp.Body).Decode(&mailMessage)
	if err != nil {
		return err
	}

	fmt.Println("\nFrom   :", mailMessage.Data.From)
	fmt.Println("Subject:", mailMessage.Data.Subject)
	fmt.Println()
	fmt.Println(mailMessage.Data.Parts[0].Body)
	return nil
}

func main() {
	// TODO: consider allow to retrieve more than one message.
	if len(os.Args) != 2 {
		fmt.Println("Usage: mailin8 <local-part>")
		os.Exit(1)
	}

	localPart := os.Args[1]
	mbxDetails, err := getMailboxDetails(localPart)
	if err != nil {
		fmt.Println("failed to get message ID:", err)
		os.Exit(1)
	}

	numberMsgs := len(mbxDetails.PublicMsgs)
	if numberMsgs == 0 {
		fmt.Println("no messages in inbox")
		os.Exit(0)
	}

	latestMsg := mbxDetails.PublicMsgs[numberMsgs-1]

	cookies, err := getCookies(latestMsg)
	if err != nil {
		fmt.Println("failed to get cookies:", err)
		os.Exit(1)
	}

	err = getMail(latestMsg, cookies)
	if err != nil {
		fmt.Println("failed to get mail:", err)
		os.Exit(1)
	}
}
